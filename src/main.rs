// Listing 2-1: 사용자가 추리한 값을 입력 받아 그대로 출력하는 코드
// 이 코드에 담긴 다양한 정보를 하나씩 살펴보자. 사용자 입력을 받고 결과값을 표시하기 위해 
// io (input/output) 라이브러리를 스코프로 가져와야한다. io 라이브러리는 std라고 불리는 표준 라이브러리가 있다. 
use std::io;

// 러스트는 모든 프로그램의 스코프에 prelude 내의 타입들을 가져온다. 만약 원하는 타입이 prelude에 없다면 
// use문을 활용해 명시적으로 그 타입들을 가져와야 한다. std::io는 사용자의 입력을 받는 것을 포함해 io와 관련된 기능을 제공한다.

// fn 문법
// fn 문법은 새로움 함수를 선언해 ()에 인자가 없음을 나타내고 { 는 함수 본문의 시작을 나타낸다.
    fn main() {
    // 추리값 처리하기 
        
    /*
    프로그램의 첫 부분은 사용자 입력 요청, 입력값의 처리 후 입력값이 기대하던 형식인지 검증한다.
        
     첫 시작은 플레이어가 추리한 값을 입력 받을 수 있게 할 것이다
     */
        
    
    // 1장에서 배웠듯이 println은 string을 화면에 표시하는 매크로이다.
    // 이 코드는 게임에 대한 설명과 사용자의 입력을 요청하는 글자를 표시한다. 
    println!("Guess the number!");

    println!("Please input your guess.");

    // 값을 변수에 저장하기 
    // 다음으로 우리는 다음 코드처럼 사용자의 입력값을 저장할 공간을 생성할 수 있다.
    let mut guess = String::new();

    // 이제 프로그램이 점점 흥미러워지고 있다! 이 짧은 라인에서 여러 일들이 벌어진다. 이 라인이 변수를 
    // 생성하는 let문임을 주목하자. 다음 코드는 변수를 선언하는 예시이다.
    // let foo = bar;

    // 이 라인은 foo라는 변수를 선언하고 bar라는 값과 묶는다. 러스트에서 변수는 기본적으로 불변이다.
    // 다음 예시는 변수앞에 mut를 이용해 가변변수를 만드는 법을 보여준다.
    // let foo = 5 // immutable
    // let mut bar = 5; // mutable

    // 이제 let mut guess가 guess라는 이름의 가변변수임을 알 수 있다. =의 반대편의 값은 guess와 묶이게 되는데 
    // 이번 예시에서는 함수 String::new의 결과값인 새로운 String 인스턴스가 묶이는 대상이 된다.
    // String은 표준 라이브러리에서 제공하는 확장 가능한(growable) UTF-8인코딩의 문자열 타입이다.

    // ::new에 있는 ::는 new가 String 타입의 연관함수임을 나타낸다. 연관함수는 하나의 타입을 위한 함수이며, 
    // 이 경우에는 하나의 string 인스턴스가 아니라 String 타입을 위한 함수이다. 몇몇 언어에서는 이것을 정적 메소드라 부른다.

    // new 함수는 새로운 빈 String을 생성한다. new 함수는 새로운 값을 생성하기 위한 일반적 이름으로 많은 타입에서 찾아볼 수 있다.
    // 요약하자면 let mut guess = String::new(); 라인은 새로운 빈 String 인스턴스와 연결된 가변변수를 생성한다.

    // 프로그램에 첫번째 라인에 use std::io; 를 이용해 표준 라이브러리의 input/output 기능을 포함한것을 떠올려보자
    // 이제 우리는 io의 연관함수는 stdin을 호출한다.

    // io::stdin().read_line(&mut guess)
    //   .expect("Failed to read line");
    
        // 만약 프로그램 시작점에 use std::io가 없다면 함수 호출 시 std::io::stdin 처럼 작성해야 한다.
        // stdin 함수는 터미널의 표준 입력의 핸들(handle)의 타입인 std::io::Stdin의 인스턴스를 돌려준다. 
        
        // 코드의 다음 부분인 .read_line(&mut guess)는 사용자로부터 입력을 받기 위해 표준 핸들에서 .read_line(&mut guess) 메소드를 호출한다. 
        // 또한 read_line에 &mut guess를 인자로 하나 넘긴다.
    
        // read_line은 사용자가 표준 입력에 입력할 때마다 입력된 문자들을 하나의 문자열에 저장하므로 인자로 값을 저장할 문자열이 필요하다.
        // 그 문자열 인자는 사용자 입력을 추가하면서 변경되므로 가변이어아 한다. 
    
        // &는 코드의 여러 부분에서 데이터를 여러번 메모리로 복사하지 않고 접근하기 위한 방법을 제공하는 참조자임을 나타낸다.
        // 참조자는 복잡한 특성으로서 큰 이점 중 하나가 참조자를 사용함으로써 얻는 안정성과 용이성이다. 이 프로그램을 작성하기 위해 
        // 참조자의 자세한 내용을 알 필요는 없다. 
    
        // 4장에서 참조자에 대해 전체적을 설명한 것. 지금 당장은 참조자가 변수처럼 기본적으로 불변임을 알기만 하면 된다.
        // 따라서 가변으로 바꾸기 위해서 &guess가 아니라 &mut guess로 작성해야 한다. 
        
        // 한 라인처럼 보이지만 사실은 이라인과 논리적으로 연결된 라인이 더 있다.
        // .expect("Failed to read line");
    
    // io::stdin().read_line(&mut guess)
    // .foo() 형태의 문법으로 메소드를 호출할 경우 긴 라인을 나누기 위해 다음 줄과 여백을 넣는 것이 바람직하다.
    // 위 코드를 아래처럼 쓸수 있다.
    io::stdin().read_line(&mut guess).expect("Failed to read line");

    println!("You guessed: {}", guess);

}
